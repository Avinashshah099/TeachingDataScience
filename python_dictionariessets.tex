%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{}
\begin{center}
{\Large Containers}
\end{center}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{}
\begin{center}
{\Large Sets}
\end{center}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Sets}
  \begin{itemize}
  \item Collection with all elements  unique.
  \item Unordered. 
  \item Variable length, heterogeneous, arbitrarily nest-able (*)
  \item Ideal for membership queries
  \end{itemize}
  \begin{lstlisting}
some_set = {1, 2, 3, 4, 4, 4, 4}
another_set = {4, 5, 6}
print(some_set)
\end{lstlisting}

(* non mutable tuples can be added but not mutable Lists or Sets)
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Empty Set}
  \begin{itemize}
  \item Creating an empty set
\item Do  *not* use the \lstinline|empty set = {}|
\item Use \lstinline|empty_set = set()|
  \end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Sets: Hash tables}
  \begin{itemize}
  \item The Python dict is essentially a hash table. 
  \item Essentially the keys are transformed into table positions by a hashing function
\item Insertion in set is done through set.add() function, where an appropriate record value is created to store in the hash table.
\item Union:- Two sets can be merged using union() function or | operator. Both Hash Table values are accessed and traversed with merge operation perform on them to combine the elements, at the same time duplicates are removed.
\item And so on \ldots

  \end{itemize}

  \tiny{(Ref: Internal working of Set in Python - Geeks for Geeks)}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Unique Membership} 

\begin{lstlisting}
my_list = [1, 2, 3, 0, 5, 10, 11, 1, 5]
my_set = set(my_list)
print(my_set)
print(len(my_set))
print(len(my_list))

>>> S = set()
>>> S.add(1)
>>> S.add('two')
>>> S.add(1)
>>> S
set([1, 'two'])
\end{lstlisting}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Checking for membership}
\begin{lstlisting}
my_set = {1, 2, 3, 4}
val = 1
print("The value", val ,"appears in the variable my_set:", val in my_set)

val = 0
print("The value", val ,"appears in the variable my_set:", val in my_set)
\end{lstlisting}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Immutable Sets}
Sets are implemented in a way, which doesn't allow mutable objects. The following example demonstrates that we cannot include for example lists as elements:
\begin{lstlisting}
>>> cities = set(["Frankfurt", "Basel","Freiburg"])
>>> cities.add("Strasbourg")
>>> cities
{'Freiburg', 'Basel', 'Frankfurt', 'Strasbourg'}
>>> 
\end{lstlisting}
Frozensets are like sets except that they cannot be changed, i.e. they are immutable:
\begin{lstlisting}
>>> cities = frozenset(["Frankfurt", "Basel","Freiburg"])
>>> cities.add("Strasbourg")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'frozenset' object has no attribute 'add'
>>> 
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Frozensets}
Though sets can't contain mutable objects, sets are mutable: 

\begin{lstlisting}
>>> cities = set((("Python","Perl"), ("Paris", "Berlin", "London")))
>>> cities = set((["Python","Perl"], ["Paris", "Berlin", "London"]))
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
>>> 
\end{lstlisting}

\end{frame}
%


%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{frame}[fragile]\frametitle{``not in'' operator}
%\begin{lstlisting}
%val = 5
%print("Value {d} does not appear in my_set: {tf}".format(d=val, tf=(val not in some_set)))
%val = 1
%print("Value {d} does not appear in my_set: {tf}".format(d=val, tf=(val not in some_set)))
%\end{lstlisting}
%\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Sets Operators}
  \begin{lstlisting}
    set_a.add(x) # add an element to a set
    
    set_a.remove(x) # remove an element from a set
    
    set_a - set_b # elements in a but not in b. Equivalent to set_a.difference(set_b)
    
\end{lstlisting}
What are the operators for Union, Intersection? Intuitively?
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Sets Operators}

  \begin{lstlisting}

    set_a | set_b # elements in a or b. Equivalent to set_a.union(set_b)
    
    set_a & set_b # elements in both a and b. Equivalent to set_a.intersection(set_b)
    
    set_a ^ set_b # elements in a or b but not both. Equivalent to set_a.symmetric_difference(set_b)
    
    set_a <= set_b # tests whether every element in set_a is in set_b. Equivalent to set_a.issubset(set_b)
    
\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile] \frametitle{Sets Exercise}
Try the above yourself using the my\_set and another\_set variables from above, and compute the difference, union, intersection, and symmetric difference, between the two sets.
  \begin{lstlisting}
set_A = {1, 2, 3, 4, 5}
set_B = {4, 5, 6, 7}
print("Set A", set_A)
print("Set B", set_B)
print("Difference A-B", ... )
print("Union", ...)
print("Intersection", ...)
print("Symmetric Difference", ...)
\end{lstlisting}
\end{frame}

%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{frame}[fragile]\frametitle{A set of counters}
%Suppose you are given a string and you want to count how many times each letter
%appears. There are several ways you could do it:
%  \begin{itemize}
%  \item  You could create 26 variables, one for each letter of the alphabet. Then you
%could traverse the string and, for each character, increment the corresponding
%counter, probably using a chained conditional.
%  \item  You could create a list with 26 elements. Then you could convert each
%character to a number (using the built-in function ord), use the number as
%an index into the list, and increment the appropriate counter.
%  \item  You could create a dictionary with characters as keys and counters as the
%corresponding values. The ﬁrst time you see a character, you would add
%an item to the dictionary. After that you would increment the value of an
%existing item.
%  \end{itemize}
%\end{frame}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{frame}[fragile]\frametitle{A set of counters}
%Suppose you are given a string and you want to count how many times each letter
%appears. There are several ways you could do it:
%  \begin{itemize}
%  \item  Each of these options performs the same computation, but each of them implements
%that computation in a different way.
%  \item  An implementation is a way of performing a computation; some implementations
%are better than others. 
%  \item  For example, an advantage of the dictionary implementation is that we don’t have to know ahead of time which letters appear in the string
%and we only have to make room for the letters that do appear.
%  \end{itemize}
%  \begin{lstlisting}
%word = 'brontosaurus'
%d = dict()
%for c in word:
%	if c not in d:
%		d[c] = 1
%	else:
%		d[c] = d[c] + 1
%print(d)
%\end{lstlisting}
%We are effectively computing a histogram, which is a statistical term for a set of
%counters (or frequencies).
%\lstinline|{'a': 1, 'b': 1, 'o': 2, 'n': 1, 's': 2, 'r': 2, 'u': 2, 't': 1}|
%\end{frame}
%
%
%\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{}
\begin{center}
{\Large Dictionaries}
\end{center}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Dictionaries}
  \begin{itemize}
  \item Dictionaries, sometimes called dicts, maps, or, rarely, hashes are data structures containing key-value pairs. 
  \item Dictionaries have a set of unique keys and are used to retrieve the value information associated with these keys. 
  \item Lookup into a dictionary is very efficient. 
  \item Accessed by key, not offset
  \item Un-ordered collections of arbitrary objects
  \item Variable length, heterogeneous, arbitrarily nest-able
%  \item Of the category mutable mapping
%  \item Tables of object references (hash tables)
  \end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Dictionaries}
  \begin{itemize}
  \item Dictionaries are specified by curly braces, { }, containing zero or more comma separated key-value pairs, where the keys and values are separated by a colon, :
  \item Like a list, values for a particular key are retrieved by passing the query key into square brackets.
  \end{itemize}
\begin{lstlisting}
>>> D = { }
>>> D['a'] = 1
>>> D[2] = 'b'
>>> D
{'a': 1, 2: 'b'}
\end{lstlisting}

  
  Dictionaries can be created and initialized using the following syntax:
\begin{lstlisting}
>>> D = { 'a':1, 2:'b' }
>>> D['a']
1
\end{lstlisting}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Exercise}
\begin{itemize}
\item Write a Python program to count the number of characters (character frequency) in a string.
Sample String : google.com'
Expected Result : {'o': 3, 'g': 2, '.': 1, 'e': 1, 'l': 1, 'm': 1, 'c': 1}
\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Dictionary}
  The \texttt{for} statement can be used to loop over keys of a dictionary:
  
  \begin{columns}[c]
    \begin{column}{0.5\linewidth}
\begin{lstlisting}
>>> D = { 'a':1, 'b':2 }
>>> for val in D.keys():
...   print(val)
'a'
'b'
\end{lstlisting}
    \end{column}
    \begin{column}{0.4\linewidth}
      \raggedleft
      Loop over dictionary~\emph{keys}.

      \emph{The \texttt{.keys()} part can be omitted, as it's the
        default!}
    \end{column}
  \end{columns}

  If you want to loop over dictionary \emph{values}, you have to explicitly request it.

  
  \begin{columns}[c]
    \begin{column}{0.5\linewidth}
\begin{lstlisting}
>>> D = { 'a':1, 'b':2 }
>>> for val in D.values():
...   print(val)
1
2
\end{lstlisting}
    \end{column}
    \begin{column}{0.4\linewidth}
      \raggedleft
      Loop over dictionary~\emph{values}

      \emph{The \texttt{.values()} cannot be omitted!}
    \end{column}
  \end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Dictionaries Exercise}
  \begin{itemize}
  \item Find the common keys in `a\_dict` and `b\_dict`
  \item Find the common values in `a\_dict` and `b\_dict`
  \end{itemize}
\begin{lstlisting}
a_dict = {"a":"e", "b":5, "c":3, "d": 4}
b_dict = {"c":5, "d":6}

# your code here

print("Common keys", ...)
print("Common values", ...)
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Exercise}
\begin{itemize}
\item With a given integral number n, write a program to generate a dictionary that contains (i, i*i) such that is an integral number between 1 and n (both included). and then the program should print the dictionary.
\item Suppose the following input is supplied to the program:8
\item Then, the output should be:{1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64}
%\item Hints: In case of input data being supplied to the question, it should be assumed to be a console input.
%Consider use dict()
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Solution}
\begin{lstlisting}
n=int(input("Enter : "))
d=dict()
for i in range(1,n+1):
    d[i]=i*i

print(d)
\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Exercises}
\begin{itemize}
\item Write a function \texttt{invert(D)} that takes a dictionary \texttt{D} and returns a dictionary \texttt{Dinv} with keys and values swapped. (We assume that \texttt{D} is 1-1.)
\item Example correct output:
\begin{lstlisting}
>>> D = { 'CH':'Switzerland', 'I':'Italy', 'F':'France' }
>>> Dinv = # Your code here
>>> print(Dinv)
{ 'Switzerland':'CH', 'France':'F', 'Italy':'I' }
\end{lstlisting}
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Dictionaries and files}
Counting words in a given text
\begin{lstlisting}
But soft what light through yonder window breaks
It is the east and Juliet is the sun
Arise fair sun and kill the envious moon
Who is already sick and pale with grief
\end{lstlisting}

  
  Dictionaries can be created and initialized using the following syntax:
\begin{lstlisting}
fhand = open(fname)

counts = dict()
for line in fhand:
	words = line.split()
	for word in words:
		if word not in counts:
			counts[word] = 1
		else:
		    counts[word] += 1
print(counts)
\end{lstlisting}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Default Dict}
  \begin{itemize}
  \item Is like a regular dictionary, except that when you try	to look up a key it doesn't	contain, it first adds a value for it using a zero-argument function you provided when you created it.	
  \begin{lstlisting}
word_counts = defaultdict(int) # assigns 0 for the newly added key
for word in document:
	word_counts[word]	+= 1
  \end{lstlisting}
\item Can also be useful with list	or dict	or even your	own functions
  \begin{lstlisting}
ddlist = defaultdict(list) # assigns empty list for the newly added key
ddlist[2].append(1) 
  \end{lstlisting}
\item When 2 was not present, added it with value as empty list, to which 1 was added
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Without Default Dict}
Without:
\begin{lstlisting}
names = ['raymond', 'rachel', 'matthew', 'roger',
         'betty', 'melissa', 'judith', 'charlie']

# In this example, we're grouping by name length
d = {}
for name in names:
    key = len(name)
    if key not in d:
        d[key] = []
    d[key].append(name)

# {5: ['roger', 'betty'], 6: ['rachel', 'judith'], 7: ['raymond', 'matthew', 'melissa', 'charlie']}

d = {}
for name in names:
    key = len(name)
    d.setdefault(key, []).append(name)
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{With Default Dict}
Better:
\begin{lstlisting}
names = ['raymond', 'rachel', 'matthew', 'roger',
         'betty', 'melissa', 'judith', 'charlie']

d = defaultdict(list)
for name in names:
    key = len(name)
    d[key].append(name)
\end{lstlisting}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Counter}
  \begin{itemize}
  \item A Counter turns a sequence of values into a defaultdict(int)-like object mapping keys to counts.	
  \begin{lstlisting}
from collections import Counter
c = Counter([0, 1, 2, 0]) # c is (basically) { 0 :	2, 1 : 1, 2 : 1}
  \end{lstlisting}
\item This gives us a very simple way to	solve our word\_counts problem
  \begin{lstlisting}
word_counts	= Counter(document)
  \end{lstlisting}
  \end{itemize}
\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
  \frametitle{The `{\ttfamily\bfseries in}' operator}

  \begin{itemize}
  \item {\texttt{x in D}; \texttt{x in D.keys()}}: Evaluates to \texttt{True} if \texttt{x} is equal to a \emph{key}
    in the \texttt{D} dictionary.
  \item {\texttt{x in D.values()}}:  Evaluates to \texttt{True} if \texttt{x} is equal to a \emph{value}
    in the \texttt{D} dictionary.
  \end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Combining (Nesting) Data Structures}
\begin{itemize}
\item There are many opportunities to combine data types. 
\item Lists can be populated by arbitrary data structures. 
\item Similarly, you can use any type as the value in a dictionary. 
\end{itemize}
\begin{lstlisting}
print("lists of lists")
lol = [[1, 2, 3], [4, 5, 6, 7]]
lol_2 = [[4, 5, 6], [7, 8, 9]]
print("lists of lists of lists")
lolol = [lol, lol_2]
print("Lolol:", lolol)
print("data structures as values in a dictionary")
dlol = {"lol":lol, "lol_2":lol_2}
print(dlol)
print("retrieving data from this dictionary")
print(dlol["lol"])
print(dlol["lol"][0])
print(dlol["lol"][0][0])
\end{lstlisting}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Exercise}
You are given the following data structure.
\begin{lstlisting}
data = {
    "Panos": {
        "Job":"Professor", 
        "YOB": "1976", 
        "Children": ["Gregory", "Anna"]
        }, 
    "Joe": {
        "Job":"Data Scientist", 
        "YOB": "1981"
        }
    }
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Exercise}
You need to write code that

\begin{itemize}
\item Prints the job of Joe
\item Prints the year of birth of Panos; prints the age of Panos
\item Prints the children of Panos
\item Prints the second child of Panos
\item Prints the number of people\_entries\_ in the data. (Notice that it is much harder to find all the people in the data, eg the children)
\item Checks if Maria is in the data
\item Checks if Panos has children. Would you code work when the list of children is empty?
\item Checks if Joe has children. How can you handle the lack of the corresponding key?
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Exercise}
\begin{itemize}
\item You need to write code that categorizes each mail message by which day of
the week the mail came. Sample line: \lstinline|From stephen.marquard@uct.ac.za Sat Jan 5 09:14:16 2008|
\item Sample answer: \lstinline|{'Fri': 20, 'Thu': 6, 'Sat': 1}|
\end{itemize}
\end{frame}


%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{frame}[fragile]\frametitle{Mutable vs Immutable}
%  Some objects (e.g., \texttt{tuple}, \texttt{int}, \texttt{str})
%  are \emph{immutable} and cannot be modified.
%\begin{lstlisting}
%>>> S = 'UZH'
%>>> S[2] = 'G'
%Traceback (most recent call last):
%  File "<stdin>", line 1, in <module>
%TypeError: 'str' object does not support item assignment
%\end{lstlisting}
%
%
%  
%  \texttt{list}, \texttt{dict}, \texttt{set} and user-defined objects
%  are \emph{mutable} and can be modified in-place.
%\end{frame}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{frame}[fragile]\frametitle{Dictionary, sets and mutable objects}
%  \begin{itemize}
%    \item
%  Not all objects can be used as dictionary \emph{keys} or items in a
%  set:
%  \begin{itemize}
%    \item
%      \textit{Immutable} objects \textbf{can be} used as \texttt{dict} keys or set items.
%    \item
%      \textit{Mutable} objects  \textbf{cannot be} used as \texttt{dict} keys or set items.
%    \end{itemize}
%
%\item A dictionary is
%      essentially a \href{http://en.wikipedia.org/wiki/Hash_table}{Hash
%        Table}
%\item Therefore keys of a dictionary must be \textit{hashable}
%      objects.  
%\item If objects were allowed to mutate, their hash value
%      would change too and we would lose the mapping.)
%\end{itemize}      
%\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]\frametitle{Dictionaries operations (recap)}
  \begin{itemize}
  \item empty  \lstinline|d1 = {}|
  \item two-item \lstinline|d2 = {'spam': 2, 'eggs': 3}|
  \item nesting \lstinline|d3 = {'food': {'ham': 1, 'egg': 2}}|
  \item indexing \lstinline|d2['eggs'], d3['food']['ham']|
  \item methods \lstinline|d2.has key('eggs'), d2.keys(), d2.values()|
  \item length \lstinline| len(d1)|
  \item add/change \lstinline|d2[key] = new|
  \item deleting \lstinline|del d2[key]|
  \end{itemize}
\end{frame}